---
layout: documentation
title: ReactiveX - Buffer operator
id: buffer
---

<ol class="breadcrumb">
  <li><a href="{{ site.url }}/documentation/operators.html">Operators</a></li>
  <li><a href="{{ site.url }}/documentation/operators.html#transforming">Transforming</a></li>
  <li class="active">Buffer</li>
</ol>

<h1>Buffer</h1>
<h3>periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</h3>

<figure>
 <img src="images/Buffer.png" style="width:100%;" alt="Buffer" />
 <figcaption><p>
  The <span class="operator">Buffer</span> operator transforms an Observable that emits items into
  an Observable that emits buffered collections of those items. There are a number of variants in
  the various language-specific implementations of <span class="operator">Buffer</span> that
  differ in how they choose which items go in which buffers.
 </p><p>
  Note that if the source Observable issues an <code>onError</code> notification,
  <span class="operator">Buffer</span> will pass on this notification immediately without first
  emitting the buffer it is in the process of assembling, even if that buffer contains items that
  were emitted by the source Observable before it issued the error notification.
 </p></figcaption>
</figure>
<p>
  The <a href="window.html"><span class="operator">Window</span></a> operator is similar to
  <span class="operator">Buffer</span> but collects items into separate Observables rather than
  into data structures before reemitting them.
</p>

<h4>See Also</h4>
<ul>
  <li><a href="window.html"><span class="operator">Window</span></a></li>
  <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Buffer"><cite>Introduction to Rx</cite>: Buffer</a></li>
  <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#BufferRevisted"><cite>Introduction to Rx</cite>: Buffer revisited</a></li>
  <li><a href="http://rxwiki.wikidot.com/101samples#toc26"><cite>101 Rx Samples</cite>: Buffer &mdash; Simple</a></li>
</ul>

<h2>Language-Specific Information:</h2>

<div class="panel-group operators-by-language" id="accordion" role="tablist" aria-multiselectable="true">
  {% lang_operator RxCpp buffer pairwise %}
    <p>
    RxCpp implements two variants of <span class="operator">Buffer</span>:
    </p>
    <h4><code>buffer(count)</code></h4>
    <figure class="variant">
    <img src="images/buffer3.png" style="width:100%;" alt="buffer(count)" />
    <figcaption>
     <p><code>buffer(count)</code> emits non-overlapping buffers in the form of
        <code>vector</code>s, each of which contains at most <code>count</code> items from the
        source Observable (the final emitted <code>vector</code> may have fewer than
        <code>count</code> items).</p>
    </figcaption>
    </figure>
    <h4><code>buffer(count, skip)</code></h4>
    <figure class="variant">
    <img src="images/buffer4.png" style="width:100%;" alt="buffer(count,skip)" />
    <figcaption>
     <p><code>buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
        emitted item from the source Observable, and every <code>skip</code> items thereafter, and
        fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
        subsequent ones. It emits these buffers as <code>vector</code>s. Depending on the values
        of <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers
        may contain the same item), or they may have gaps (where items emitted by the source
        Observable are not represented in any buffer).</p>
    </figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxGroovy buffer %}
    <p>
    In RxGroovy there are several variants of <span class="operator">Buffer</span>:
    </p>
    <h4><code>buffer(count)</code></h4>
    <figure class="variant">
    <img src="images/buffer3.png" style="width:100%;" alt="buffer(count)" />
    <figcaption>
     <p><code>buffer(count)</code> emits non-overlapping buffers in the form of
        <code>List</code>s, each of which contains at most <code>count</code> items from the
        source Observable (the final emitted <code>List</code> may have fewer than
        <code>count</code> items).</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)"><code>buffer(int)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(count, skip)</code></h4>
    <figure class="variant">
    <img src="images/buffer4.png" style="width:100%;" alt="buffer(count,skip)" />
    <figcaption>
     <p><code>buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
        emitted item from the source Observable, and every <code>skip</code> items thereafter, and
        fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
        subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of
        <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
        contain the same item), or they may have gaps (where items emitted by the source
        Observable are not represented in any buffer).</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)"><code>buffer(int,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(bufferClosingSelector)</code></h4>
    <figure class="variant">
    <img src="images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)" />
    <figcaption>
     <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code>
        begins to collect its emissions into a <code>List</code>, and it also calls
        <code>bufferClosingSelector</code> to generate a second Observable. When this second
        Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current
        <code>List</code> and repeats this process: beginning a new <code>List</code> and calling
        <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this
        until the source Observable terminates.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)"><code>buffer(Func0)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(boundary</code>[<code>, initialCapacity</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer8.png" style="width:100%;" alt="buffer(boundary)" />
    <figcaption>
     <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time
        that Observable emits an item, it creates a new <code>List</code> to begin collecting
        items emitted by the source Observable and emits the previous <code>List</code>.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)"><code>buffer(Observable)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)"><code>buffer(Observable,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(bufferOpenings, bufferClosingSelector)</code></h4>
    <figure class="variant">
    <img src="images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)" />
    <figcaption>
     <p><code>buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
        <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it
        observes such an emitted item, it creates a new <code>List</code> to begin collecting
        items emitted by the source Observable and it passes the <code>bufferOpenings</code>
        Observable into the <code>closingSelector</code> function. That function returns an
        Observable. <code>buffer</code> monitors that Observable and when it detects an emitted
        item from it, it closes the <code>List</code> and emits it as its own emission.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)"><code>buffer(Observable,Func1)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(timespan, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer5.png" style="width:100%;" alt="buffer(timespan,unit)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;unit)</code> emits a new <code>List</code> of items
        periodically, every <code>timespan</code> amount of time, containing all items emitted by
        the source Observable since the previous bundle emission or, in the case of the first
        bundle, since the subscription to the source Observable. There is also a version of this
        variant of the operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a
        parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code>
        Scheduler.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer6.png" style="width:100%;" alt="buffer(timespan,unit,count)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;unit,&#8239;count)</code> emits a new <code>List</code> of
        items for every <code>count</code> items emitted by the source Observable, or, if
        <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of
        however many items the source Observable has emitted in that span, even if this is fewer
        than <code>count</code>. There is also a version of this variant of the operator that
        takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>computation</code> scheduler.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)"><code>buffer(long,TimeUnit,int)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)"><code>buffer(long,TimeUnit,int,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer7.png" style="width:100%;" alt="buffer(timespan,timeshift,unit)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;timeshift,&#8239;unit)</code> creates a new <code>List</code>
        of items every <code>timeshift</code> period of time, and fills this bundle with every
        item emitted by the source Observable from that time until <code>timespan</code> time has
        passed since the bundle&#8217;s creation, before emitting this <code>List</code> as its
        own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted
        bundles will represent time periods that overlap and so they may contain duplicate items.
        There is also a version of this variant of the operator that takes a
        <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>computation</code> scheduler.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <p>
     You can use the <span class="operator">Buffer</span> operator to implement backpressure (that
     is, to cope with an Observable that may produce items too quickly for its observer to consume).
    </p>
    <figure class="variant">
     <img src="images/bp.buffer2.png" style="width:100%;" alt="Buffer as a backpressure strategy" />
     <figcaption><p>
      Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making
      them more manageable. You could, for example, close and emit a buffer of items from a bursty
      Observable periodically, at a regular interval of time.
     </p>
     <h4>Sample Code</h4>
     <div class="code groovy"><pre>
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);</pre></div>
     </figcaption>
    </figure>
    <figure class="variant">
     <img src="images/bp.buffer1.png" style="width:100%;" alt="Buffer as a backpressure strategy" />
     <figcaption><p>
      Or you could get fancy, and collect items in buffers during the bursty periods and emit them
      at the end of each burst, by using the
      <a href="debounce.html"><span class="operator">Debounce</span></a> operator
      to emit a buffer closing indicator to the buffer operator.
     </p>
     <h4>Sample Code</h4>
     <div class="code groovy"><pre>
// we have to multicast the original bursty Observable so we can use it
// both as our source and as the source for our buffer closing selector:
Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();
// burstyDebounced will be our buffer closing selector:
Observable&lt;Integer&gt; burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);
// and this, finally, is the Observable of buffers we're interested in:
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);</pre></div>
     </figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJava buffer %}
    <p>
    In RxJava there are several variants of <span class="operator">Buffer</span>:
    </p>
    <h4><code>buffer(count)</code></h4>
    <figure class="variant">
    <img src="images/buffer3.png" style="width:100%;" alt="buffer(count)" />
    <figcaption>
     <p><code>buffer(count)</code> emits non-overlapping buffers in the form of
        <code>List</code>s, each of which contains at most <code>count</code> items from the
        source Observable (the final emitted <code>List</code> may have fewer than
        <code>count</code> items).</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int)"><code>buffer(int)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(count, skip)</code></h4>
    <figure class="variant">
    <img src="images/buffer4.png" style="width:100%;" alt="buffer(count,skip)" />
    <figcaption>
     <p><code>buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
        emitted item from the source Observable, and every <code>skip</code> items thereafter, and
        fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
        subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of
        <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
        contain the same item), or they may have gaps (where items emitted by the source
        Observable are not represented in any buffer).</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(int,%20int)"><code>buffer(int,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(bufferClosingSelector)</code></h4>
    <figure class="variant">
    <img src="images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)" />
    <figcaption>
     <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code>
        begins to collect its emissions into a <code>List</code>, and it also calls
        <code>bufferClosingSelector</code> to generate a second Observable. When this second
        Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current
        <code>List</code> and repeats this process: beginning a new <code>List</code> and calling
        <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this
        until the source Observable terminates.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)"><code>buffer(Func0)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(boundary)</code></h4>
    <figure class="variant">
    <img src="images/buffer8.png" style="width:100%;" alt="buffer(boundary)" />
    <figcaption>
     <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time
        that Observable emits an item, it creates a new <code>List</code> to begin collecting
        items emitted by the source Observable and emits the previous <code>List</code>.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable)"><code>buffer(Observable)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20int)"><code>buffer(Observable,int)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(bufferOpenings, bufferClosingSelector)</code></h4>
    <figure class="variant">
    <img src="images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)" />
    <figcaption>
     <p><code>buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
        <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it
        observes such an emitted item, it creates a new <code>List</code> to begin collecting
        items emitted by the source Observable and it passes the <code>bufferOpenings</code>
        Observable into the <code>closingSelector</code> function. That function returns an
        Observable. <code>buffer</code> monitors that Observable and when it detects an emitted
        item from it, it closes the <code>List</code> and emits it as its own emission.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable,%20rx.functions.Func1)"><code>buffer(Observable,Func1)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(timespan, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer5.png" style="width:100%;" alt="buffer(timespan,unit)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;unit)</code> emits a new <code>List</code> of items
        periodically, every <code>timespan</code> amount of time, containing all items emitted by
        the source Observable since the previous bundle emission or, in the case of the first
        bundle, since the subscription to the source Observable. There is also a version of this
        variant of the operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a
        parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code>
        scheduler.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer6.png" style="width:100%;" alt="buffer(timespan,unit,count)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;unit,&#8239;count)</code> emits a new <code>List</code> of
        items for every <code>count</code> items emitted by the source Observable, or, if
        <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of
        however many items the source Observable has emitted in that span, even if this is fewer
        than <code>count</code>. There is also a version of this variant of the operator that
        takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>computation</code> scheduler.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int)"><code>buffer(long,TimeUnit,int)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20java.util.concurrent.TimeUnit,%20int,%20rx.Scheduler)"><code>buffer(long,TimeUnit,int,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <h4><code>buffer(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
    <figure class="variant">
    <img src="images/buffer7.png" style="width:100%;" alt="buffer(timespan,timeshift,unit)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;timeshift,&#8239;unit)</code> creates a new <code>List</code>
        of items every <code>timeshift</code> period of time, and fills this bundle with every
        item emitted by the source Observable from that time until <code>timespan</code> time has
        passed since the bundle&#8217;s creation, before emitting this <code>List</code> as its
        own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted
        bundles will represent time periods that overlap and so they may contain duplicate items.
        There is also a version of this variant of the operator that takes a
        <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>computation</code> scheduler.</p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit)"><code>buffer(long,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#buffer(long,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>buffer(long,long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <p>
     You can use the <span class="operator">Buffer</span> operator to implement backpressure (that
     is, to cope with an Observable that may produce items too quickly for its observer to consume).
    </p>
    <figure class="variant">
     <img src="images/bp.buffer2.png" style="width:100%;" alt="Buffer as a backpressure strategy" />
     <figcaption><p>
      Buffer can reduce a sequence of many items to a sequence of fewer buffers-of-items, making
      them more manageable. You could, for example, close and emit a buffer of items from a bursty
      Observable periodically, at a regular interval of time.
     </p>
     <h4>Sample Code</h4>
     <div class="code java"><pre>
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = bursty.buffer(500, TimeUnit.MILLISECONDS);</pre></div>
     </figcaption>
    </figure>
    <figure class="variant">
     <img src="images/bp.buffer1.png" style="width:100%;" alt="Buffer as a backpressure strategy" />
     <figcaption><p>
      Or you could get fancy, and collect items in buffers during the bursty periods and emit them
      at the end of each burst, by using the
      <a href="debounce.html"><span class="operator">Debounce</span></a> operator
      to emit a buffer closing indicator to the buffer operator.
     </p>
     <h4>Sample Code</h4>
     <div class="code java"><pre>
// we have to multicast the original bursty Observable so we can use it
// both as our source and as the source for our buffer closing selector:
Observable&lt;Integer&gt; burstyMulticast = bursty.publish().refCount();
// burstyDebounced will be our buffer closing selector:
Observable&lt;Integer&gt; burstyDebounced = burstyMulticast.debounce(10, TimeUnit.MILLISECONDS);
// and this, finally, is the Observable of buffers we're interested in:
Observable&lt;List&lt;Integer&gt;&gt; burstyBuffered = burstyMulticast.buffer(burstyDebounced);</pre></div>
     </figcaption>
    </figure>
    <h4>See Also</h4>
    <ul>
     <li><a href="http://nerds.weddingpartyapp.com/tech/2015/01/05/debouncedbuffer-used-in-rxbus-example/"><cite>DebouncedBuffer With RxJava</cite> by Gopal Kaushik</a></li>
    </ul>
  {% endlang_operator %}

  {% lang_operator RxJS buffer bufferWithCount bufferWithTime bufferWithTimeOrCount %}
   <p>
    RxJS has four <span class="operator">Buffer</span> operators &mdash; <code>buffer</code>,
    <code>bufferWithCount</code>, <code>bufferWithTime</code>, and
    <code>bufferWithTimeOrCount</code> &mdash; each of which has variants that have different
    ways of governing which source Observable items are emitted as part of which buffers.
   </p>
   <h4><code>buffer(bufferBoundaries)</code></h4>
   <figure class="variant">
    <img src="images/buffer8.png" style="width:100%;" alt="buffer(bufferBoundaries)" />
    <figcaption>
     <p><code>buffer(bufferBoundaries)</code> monitors an Observable,
        <code>bufferBoundaries</code>. Each time that Observable emits an item, it creates a new
        collection to begin collecting items emitted by the source Observable and emits the
        previous collection.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(bufferClosingSelector)</code></h4>
   <figure class="variant">
    <img src="images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)" />
    <figcaption>
     <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code>
        begins to collect its emissions into a collection, and it also calls
        <code>bufferClosingSelector</code> to generate a second Observable. When this second
        Observable emits an item, <code>buffer</code> emits the current collection and repeats
        this process: beginning a new collection and calling <code>bufferClosingSelector</code>
        to create a new Observable to monitor. It will do this until the source Observable
        terminates.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(bufferOpenings,bufferClosingSelector)</code></h4>
   <figure class="variant">
    <img src="images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)" />
    <figcaption>
     <p><code>buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
        <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it
        observes such an emitted item, it creates a new collection to begin collecting items
        emitted by the source Observable and it passes the <code>bufferOpenings</code>
        Observable into the <code>bufferClosingSelector</code> function. That function returns an
        Observable. <code>buffer</code> monitors that Observable and when it detects an emitted
        item from it, it emits the current collection and begins a new one.</p>
    </figcaption>
   </figure>
   <p>
    <code>buffer</code> is found in each of the following distributions:
   </p>
   <ul>
    <li><code>rx.all.js</code></li>
    <li><code>rx.all.compat.js</code></li>
    <li><code>rx.coincidence.js</code></li>
   </ul>
   <p>
    <code>buffer</code> requires one of the following distributions:
   </p>
   <ul>
    <li><code>rx.js</code></li>
    <li><code>rx.compat.js</code></li>
    <li><code>rx.lite.js</code></li>
    <li><code>rx.lite.compat.js</code></li>
   </ul>
   <h4><code>bufferWithCount(count)</code></h4>
   <figure class="variant">
    <img src="images/bufferWithCount3.png" style="width:100%;" alt="bufferWithCount(count)" />
    <figcaption>
     <p><code>bufferWithCount(count)</code> emits non-overlapping buffers, each of which contains
        at most <code>count</code> items from the source Observable (the final emitted buffer may
        contain fewer than <code>count</code> items).</p>
    </figcaption>
   </figure>
   <h4><code>bufferWithCount(count, skip)</code></h4>
   <figure class="variant">
    <img src="images/bufferWithCount4.png" style="width:100%;" alt="bufferWithCount(count,skip)" />
    <figcaption>
     <p><code>bufferWithCount(count,&#8239;skip)</code> creates a new buffer starting with the
        first emitted item from the source Observable, and a new one for every <code>skip</code>
        items thereafter, and fills each buffer with <code>count</code> items: the initial item
        and <code>count-1</code> subsequent ones, emitting each buffer when it is complete.
        Depending on the values of <code>count</code> and <code>skip</code> these buffers may
        overlap (multiple buffers may contain the same item), or they may have gaps (where items
        emitted by the source Observable are not represented in any buffer).</p>
    </figcaption>
   </figure>
   <p>
    <code>bufferWithCount</code> is found in each of the following distributions:
   </p>
   <ul>
    <li><code>rx.js</code></li>
    <li><code>rx.compat.js</code></li>
    <li><code>rx.all.js</code></li>
    <li><code>rx.all.compat.js</code></li>
    <li><code>rx.lite.extras.js</code></li>
   </ul>
   <h4><code>bufferWithTime(timeSpan)</code></h4>
   <figure class="variant">
    <img src="images/bufferWithTime5.png" style="width:100%;" alt="bufferWithTime(timeSpan)" />
    <figcaption>
     <p><code>bufferWithTime(timeSpan)</code> emits a new collection of items periodically, every
        <code>timeSpan</code> milliseconds, containing all items emitted by the source Observable
        since the previous bundle emission or, in the case of the first bundle, since the
        subscription to the source Observable. There is also a version of this variant of the
        operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it
        to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p>
    </figcaption>
   </figure>
   <h4><code>bufferWithTime(timeSpan, timeShift)</code></h4>
   <figure class="variant">
    <img src="images/bufferWithTime7.png" style="width:100%;" alt="bufferWithTime(timeSpan,timeShift)" />
    <figcaption>
     <p><code>bufferWithTime(timeSpan,&#8239;timeShift)</code> creates a new collection of items
        every <code>timeShift</code> milliseconds, and fills this bundle with every item emitted
        by the source Observable from that time until <code>timeSpan</code> milliseconds has
        passed since the collection&#8217;s creation, before emitting this collection as its own
        emission. If <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted
        bundles will represent time periods that overlap and so they may contain duplicate items.
        There is also a version of this variant of the operator that takes a
        <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>timeout</code> scheduler.</p>
    </figcaption>
   </figure>
   <h4><code>bufferWithTimeOrCount(timeSpan, count)</code></h4>
   <figure class="variant">
    <img src="images/bufferWithTimeOrCount6.png" style="width:100%;" alt="bufferWithTimeOrCount(timeSpan,count)" />
    <figcaption>
     <p><code>bufferWithTimeOrCount(timeSpan,&#8239;count)</code> emits a new collection of items
        for every <code>count</code> items emitted by the source Observable, or, if
        <code>timeSpan</code> milliseconds have elapsed since its last collection emission, it
        emits a collection of however many items the source Observable has emitted in that span,
        even if this is fewer than <code>count</code>. There is also a version of this variant of
        the operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses
        it to govern the timespan; by default this variant uses the <code>timeout</code> scheduler.</p>
    </figcaption>
   </figure>
   <p>
    <code>bufferWithTime</code> and <code>bufferWithTimeOrCount</code> are found in each of the
    following distributions:
   </p>
   <ul>
    <li><code>rx.all.js</code></li>
    <li><code>rx.all.compat.js</code></li>
    <li><code>rx.time.js</code></li>
   </ul>
   <p>
    <code>bufferWithTime</code> and <code>bufferWithTimeOrCount</code> require one of the
    following distributions:
   </p>
   <ul>
    <li><code>rx.time.js</code> requires <code>rx.js</code> or <code>rx.compat.js</code></li>
    <li>otherwise: <code>rx.lite.js</code> or <code>rx.lite.compat.js</code></li>
   </ul>
  {% endlang_operator %}

  {% lang_operator RxKotlin buffer %}
   <p>
    In RxKotlin there are several variants of <span class="operator">Buffer</span>:
   </p>
   <h4><code>buffer(count)</code></h4>
   <figure class="variant">
    <img src="images/buffer3.png" style="width:100%;" alt="buffer(count)" />
    <figcaption>
     <p><code>buffer(count)</code> emits non-overlapping buffers in the form of
        <code>List</code>s, each of which contains at most <code>count</code> items from the
        source Observable (the final emitted <code>List</code> may have fewer than
        <code>count</code> items).</p>
    </figcaption>
   </figure>
   <h4><code>buffer(count, skip)</code></h4>
   <figure class="variant">
    <img src="images/buffer4.png" style="width:100%;" alt="buffer(count,skip)" />
    <figcaption>
     <p><code>buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
        emitted item from the source Observable, and every <code>skip</code> items thereafter, and
        fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
        subsequent ones. It emits these buffers as <code>List</code>s. Depending on the values of
        <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
        contain the same item), or they may have gaps (where items emitted by the source
        Observable are not represented in any buffer).</p>
    </figcaption>
   </figure>
   <h4><code>buffer(bufferClosingSelector)</code></h4>
   <figure class="variant">
    <img src="images/buffer1.png" style="width:100%;" alt="buffer(bufferClosingSelector)" />
    <figcaption>
     <p>When it subscribes to the source Observable, <code>buffer(bufferClosingSelector)</code>
        begins to collect its emissions into a <code>List</code>, and it also calls
        <code>bufferClosingSelector</code> to generate a second Observable. When this second
        Observable emits an <code>TClosing</code> object, <code>buffer</code> emits the current
        <code>List</code> and repeats this process: beginning a new <code>List</code> and calling
        <code>bufferClosingSelector</code> to create a new Observable to monitor. It will do this
        until the source Observable terminates.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(boundary)</code></h4>
   <figure class="variant">
    <img src="images/buffer8.png" style="width:100%;" alt="buffer(boundary)" />
    <figcaption>
     <p><code>buffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each time
        that Observable emits an item, it creates a new <code>List</code> to begin collecting
        items emitted by the source Observable and emits the previous <code>List</code>.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(bufferOpenings, bufferClosingSelector)</code></h4>
   <figure class="variant">
    <img src="images/buffer2.png" style="width:100%;" alt="buffer(bufferOpenings,bufferClosingSelector)" />
    <figcaption>
     <p><code>buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
        <code>bufferOpenings</code>, that emits <code>BufferOpening</code> objects. Each time it
        observes such an emitted item, it creates a new <code>List</code> to begin collecting
        items emitted by the source Observable and it passes the <code>bufferOpenings</code>
        Observable into the <code>closingSelector</code> function. That function returns an
        Observable. <code>buffer</code> monitors that Observable and when it detects an emitted
        item from it, it closes the <code>List</code> and emits it as its own emission.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(timespan, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
   <figure class="variant">
    <img src="images/buffer5.png" style="width:100%;" alt="buffer(timespan,unit)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;unit)</code> emits a new <code>List</code> of items
        periodically, every <code>timespan</code> amount of time, containing all items emitted by
        the source Observable since the previous bundle emission or, in the case of the first
        bundle, since the subscription to the source Observable.  There is also a version of this
        variant of the operator that takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a
        parameter and uses it to govern the timespan; by default this variant uses the <code>computation</code>
        scheduler.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(timespan, unit, count</code>[<code>, scheduler</code>]<code>)</code></h4>
   <figure class="variant">
    <img src="images/buffer6.png" style="width:100%;" alt="buffer(timespan,unit,count)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;unit,&#8239;count)</code> emits a new <code>List</code> of
        items for every <code>count</code> items emitted by the source Observable, or, if
        <code>timespan</code> has elapsed since its last bundle emission, it emits a bundle of
        however many items the source Observable has emitted in that span, even if this is fewer
        than <code>count</code>. There is also a version of this variant of the operator that
        takes a <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>computation</code> scheduler.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(timespan, timeshift, unit</code>[<code>, scheduler</code>]<code>)</code></h4>
   <figure class="variant">
    <img src="images/buffer7.png" style="width:100%;" alt="buffer(timespan,timeshift,unit)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;timeshift,&#8239;unit)</code> creates a new <code>List</code>
        of items every <code>timeshift</code> period of time, and fills this bundle with every
        item emitted by the source Observable from that time until <code>timespan</code> time has
        passed since the bundle&#8217;s creation, before emitting this <code>List</code> as its
        own emission. If <code>timespan</code> is longer than <code>timeshift</code>, the emitted
        bundles will represent time periods that overlap and so they may contain duplicate items.
        There is also a version of this variant of the operator that takes a
        <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan; by default this variant uses the <code>computation</code> scheduler.</p>
    </figcaption>
   </figure>
  {% endlang_operator %}

  {% lang_operator Rx.NET Buffer %}
   <p>
    In Rx.NET there are several variants of <span class="operator">Buffer</span>. For each variety
    you can either pass in the source Observable as the first parameter, or you can call it as
    an instance method of the source Observable (in which case you can omit that parameter):
   </p>
   <h4><code>Buffer(count)</code></h4>
   <figure class="variant">
    <img src="images/Buffer3.net.png" style="width:100%;" alt="Buffer(count)" />
    <figcaption>
     <p><code>Buffer(count)</code> emits non-overlapping buffers in the form of
        <code>IList</code>s, each of which contains at most <code>count</code> items from the
        source Observable (the final emitted <code>IList</code> may have fewer than
        <code>count</code> items).</p>
    </figcaption>
   </figure>
   <h4><code>Buffer(count, skip)</code></h4>
   <figure class="variant">
    <img src="images/Buffer4.net.png" style="width:100%;" alt="Buffer(count,skip)" />
    <figcaption>
     <p><code>Buffer(count,&#8239;skip)</code> creates a new buffer starting with the first
        emitted item from the source Observable, and every <code>skip</code> items thereafter, and
        fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
        subsequent ones. It emits these buffers as <code>IList</code>s. Depending on the values of
        <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
        contain the same item), or they may have gaps (where items emitted by the source
        Observable are not represented in any buffer).</p>
    </figcaption>
   </figure>
   <h4><code>Buffer(bufferClosingSelector)</code></h4>
   <figure class="variant">
    <img src="images/Buffer1.net.png" style="width:100%;" alt="Buffer(bufferClosingSelector)" />
    <figcaption>
     <p>When it subscribes to the source Observable, <code>Buffer(bufferClosingSelector)</code>
        begins to collect its emissions into an <code>IList</code>, and it also calls
        <code>bufferClosingSelector</code> to generate a second Observable. When this second
        Observable emits an <code>TBufferClosing</code> object, <code>Buffer</code> emits the
        current <code>IList</code> and repeats this process: beginning a new <code>IList</code>
        and calling <code>bufferClosingSelector</code> to create a new Observable to monitor. It
        will do this until the source Observable terminates.</p>
    </figcaption>
   </figure>
   <h4><code>Buffer(bufferOpenings,bufferClosingSelector)</code></h4>
   <figure class="variant">
    <img src="images/Buffer2.net.png" style="width:100%;" alt="Buffer(bufferOpenings,bufferClosingSelector)" />
    <figcaption>
     <p><code>Buffer(bufferOpenings,&#8239;bufferClosingSelector)</code> monitors an Observable,
        <code>BufferOpenings</code>, that emits <code>TBufferOpening</code> objects. Each time it
        observes such an emitted item, it creates a new <code>IList</code> to begin collecting
        items emitted by the source Observable and it passes the <code>TBufferOpening</code>
        object into the <code>bufferClosingSelector</code> function. That function returns an
        Observable. <code>Buffer</code> monitors that Observable and when it detects an emitted
        item from it, it closes the <code>IList</code> and emits it as its own emission.</p>
    </figcaption>
   </figure>
   <h4><code>Buffer(timeSpan)</code></h4>
   <figure class="variant">
    <img src="images/Buffer5.net.png" style="width:100%;" alt="Buffer(timeSpan)" />
    <figcaption>
     <p><code>Buffer(timeSpan)</code> emits a new <code>IList</code> of items periodically, every
        <code>timeSpan</code> amount of time, containing all items emitted by the source
        Observable since the previous bundle emission or, in the case of the first list, since
        the subscription to the source Observable. There is also a version of this variant of the
        operator that takes an <a href="../scheduler.html"><code>IScheduler</code></a> as a parameter and uses
        it to govern the timespan.</p>
    </figcaption>
   </figure>
   <h4><code>Buffer(timeSpan, count)</code></h4>
   <figure class="variant">
    <img src="images/Buffer6.net.png" style="width:100%;" alt="Buffer(timeSpan,count)" />
    <figcaption>
     <p><code>Buffer(timeSpan,&#8239;count)</code> emits a new <code>IList</code> of items for
        every <code>count</code> items emitted by the source Observable, or, if
        <code>timeSpan</code> has elapsed since its last list emission, it emits a list of
        however many items the source Observable has emitted in that span, even if this is fewer
        than <code>count</code>. There is also a version of this variant of the operator that
        takes an <a href="../scheduler.html"><code>IScheduler</code></a> as a parameter and uses it to govern
        the timespan.</p>
    </figcaption>
   </figure>
   <h4><code>Buffer(timeSpan, timeShift)</code></h4>
   <figure class="variant">
    <img src="images/Buffer7.net.png" style="width:100%;" alt="Buffer(timeSpan,timeShift)" />
    <figcaption>
     <p><code>Buffer(timeSpan,&#8239;timeShift)</code> creates a new <code>IList</code> of items
        every <code>timeShift</code> period of time, and fills this list with every item emitted
        by the source Observable from that time until <code>timeSpan</code> time has passed since
        the list&#8217;s creation, before emitting this <code>IList</code> as its own emission. If
        <code>timeSpan</code> is longer than <code>timeShift</code>, the emitted lists will
        represent time periods that overlap and so they may contain duplicate items. There is also
        a version of this variant of the operator that takes an
        <a href="../scheduler.html"><code>IScheduler</code></a> as a parameter and uses it to govern the
        timespan.</p>
    </figcaption>
   </figure>
  {% endlang_operator %}

  {% lang_operator RxPHP bufferWithCount %}
<figure class="variant">
    <figcaption>
    <p>
    RxPHP implements this operator as <code>bufferWithCount</code>.
    </p>
    <p>
    Projects each element of an observable sequence into zero or more buffers which are produced based on element count information.
    </p>
<h4>Sample Code</h4>
<div class="code php">
    <pre>
//from https://github.com/ReactiveX/RxPHP/blob/master/demo/bufferWithCount/bufferWithCount.php

$source = Rx\Observable::range(1, 6)
    ->bufferWithCount(2)
    ->subscribe($stdoutObserver);

   </pre>
</div>
<div class="output">
    <pre>
Next value: [1,2]
Next value: [3,4]
Next value: [5,6]
Complete!
    </pre>
</div>

<div class="code php">
    <pre>
//from https://github.com/ReactiveX/RxPHP/blob/master/demo/bufferWithCount/bufferWithCountAndSkip.php

$source = Rx\Observable::range(1, 6)
    ->bufferWithCount(2, 1)
    ->subscribe($stdoutObserver);

   </pre>
</div>
<div class="output">
    <pre>
Next value: [1,2]
Next value: [2,3]
Next value: [3,4]
Next value: [4,5]
Next value: [5,6]
Next value: [6]
Complete!
    </pre>
</div>
    </figcaption>
</figure>
  {% endlang_operator %}

  {% lang_operator RxPY buffer buffer_with_count buffer_with_time buffer_with_time_or_count pairwise %}
   <p>
    RxPY has several <span class="operator">Buffer</span> variants: <code>buffer</code>,
    <code>buffer_with_count</code>, <code>buffer_with_time</code>, and
    <code>buffer_with_time_or_count</code>. For each of these variants there are optional
    parameters that change the behavior of the operator. As always in RxPY, when an operator may
    take more than one optional parameter, be sure to name the parameter in the parameter list
    when you call the operator so as to avoid ambiguity.
   </p>
   <h4><code>buffer(buffer_openings)</code></h4>
   <figure class="variant">
    <img src="images/buffer8.py.png" style="width:100%;" alt="buffer(buffer_openings)" />
    <figcaption>
     <p><code>buffer(buffer_openings=boundaryObservable)</code> monitors an Observable,
        <code>buffer_openings</code>. Each time that Observable emits an item, it creates a new
        array to begin collecting items emitted by the source Observable and emits the
        previous array.</p>
    </figcaption>
   </figure>
   <h4><code>buffer(closing_selector)</code></h4>
   <figure class="variant">
    <img src="images/buffer1.py.png" style="width:100%;" alt="buffer(closing_selector)" />
    <figcaption>
     <p><code>buffer(closing_selector=closingSelector)</code> begins collecting items emitted
        by the source Observable immediately upon subscription, and also calls the
        <code>closing_selector</code> function to generate a second Observable. It monitors this
        new Observable and, when it completes or emits an item, it emits the current array,
        begins a new array to collect items from the source Observable, and calls
        <code>closing_selector</code> again to generate a new Observable to monitor in order to
        determine when to emit the new array. It repeats this process until the source Observable
        terminates, whereupon it emits the final array.</p>
    </figcaption>
   </figure>
   <figure class="variant">
    <img src="images/buffer2.py.png" style="width:100%;" alt="buffer(closing_selector,buffer_closing_selector)" />
    <figcaption>
     <p><code>buffer(closing_selector=openingSelector,&nbsp;buffer_closing_selector=closingSelector)</code>
     begins by calling <code>closing_selector</code> to get an Observable. It monitors this
     Observable, and, whenever it emits an item, <code>buffer</code> creates a new array, begins
     to collect items subsequently emitted by the source Observable into this array, and calls
     <code>buffer_closing_selector</code> to get a new Observable to govern the closing of that
     array. When this new Observable emits an item or terminates, <code>buffer</code> closes and
     emits the array that the Observable governs.</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_count(count)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_count3.py.png" style="width:100%;" alt="buffer_with_count(count)" />
    <figcaption>
     <p><code>buffer_with_count(count)</code> emits non-overlapping buffers in the form of
        arrays, each of which contains at most <code>count</code> items from the source Observable
        (the final emitted array may have fewer than <code>count</code> items).</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_count(count, skip)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_count4.py.png" style="width:100%;" alt="buffer_with_count(count,skip)" />
    <figcaption>
     <p><code>buffer_with_count(count,&#8239;skip=skip)</code> creates a new buffer starting with
        the first emitted item from the source Observable, and every <code>skip</code> items
        thereafter, and fills each buffer with <code>count</code> items: the initial item and
        <code>count-1</code> subsequent ones. It emits these buffers as arrays. Depending on the
        values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple
        buffers may contain the same item), or they may have gaps (where items emitted by the
        source Observable are not represented in any buffer).</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_time(timespan)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_time5.py.png" style="width:100%;" alt="buffer_with_time(timespan)" />
    <figcaption>
     <p><code>buffer_with_time(timespan)</code> emits a new array of items periodically, every
        <code>timespan</code> milliseconds, containing all items emitted by the source Observable
        since the previous bundle emission or, in the case of the first bundle, since the
        subscription to the source Observable. There is also a version of this variant of the
        operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan;
        by default this variant uses the <code>timeout</code> scheduler.</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_time(timespan, timeshift)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_time7.py.png" style="width:100%;" alt="buffer_with_time(timespan,timeshift)" />
    <figcaption>
     <p><code>buffer(timespan,&#8239;timeshift=timeshift)</code> creates a new array of items
        every <code>timeshift</code> milliseconds, and fills this array with every item emitted
        by the source Observable from that time until <code>timespan</code> milliseconds have
        passed since the array&#8217;s creation, before emitting this array as its own emission.
        If <code>timespan</code> is longer than <code>timeshift</code>, the emitted arrays will
        represent time periods that overlap and so they may contain duplicate items. There is also
        a version of this variant of the operator that takes a <code>scheduler</code> parameter
        and uses it to govern the timespan; by default this variant uses the <code>timeout</code>
        scheduler.</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_time_or_count(timespan, count)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_time_or_count6.py.png" style="width:100%;" alt="buffer_with_time_or_count(timespan,count)" />
    <figcaption>
     <p><code>buffer_with_time_or_count(timespan,&#8239;count)</code> emits a new array of items
        for every <code>count</code> items emitted by the source Observable, or, if
        <code>timespan</code> milliseconds have elapsed since its last bundle emission, it emits
        an array of however many items the source Observable has emitted in that span, even if
        this is fewer than <code>count</code>. There is also a version of this variant of the
        operator that takes a <code>scheduler</code> parameter and uses it to govern the timespan;
        by default this variant uses the <code>timeout</code> scheduler.</p>
    </figcaption>
   </figure>
  {% endlang_operator %}

  {% lang_operator Rx.rb buffer_with_count buffer_with_time %}
   <p>
    Rx.rb has three variants of the <span class="operator">Buffer</span> operator:
   </p>
   <h4><code>buffer_with_count(count)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_count3.py.png" style="width:100%;" alt="buffer_with_count(count)" />
    <figcaption>
     <p><code>buffer_with_count(count)</code> emits non-overlapping buffers in the form of
        arrays, each of which contains at most <code>count</code> items from the source Observable
        (the final emitted array may have fewer than <code>count</code> items).</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_count(count,skip)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_count4.rb.png" style="width:100%;" alt="buffer_with_count(count,skip)" />
    <figcaption>
     <p><code>buffer_with_count(count,&#8239;skip=skip)</code> creates a new buffer starting with
        the first emitted item from the source Observable, and every <code>skip</code> items
        thereafter, and fills each buffer with <code>count</code> items: the initial item and
        <code>count-1</code> subsequent ones. It emits these buffers as arrays. Depending on the
        values of <code>count</code> and <code>skip</code> these buffers may overlap (multiple
        buffers may contain the same item), or they may have gaps (where items emitted by the
        source Observable are not represented in any buffer).</p>
    </figcaption>
   </figure>
   <h4><code>buffer_with_time(timespan)</code></h4>
   <figure class="variant">
    <img src="images/buffer_with_time5.py.png" style="width:100%;" alt="buffer_with_time(timespan)" />
    <figcaption>
     <p><code>buffer_with_time(timespan)</code> emits a new array of items periodically, every
        <code>timespan</code> milliseconds, containing all items emitted by the source Observable
        since the previous bundle emission or, in the case of the first bundle, since the
        subscription to the source Observable.</p>
    </figcaption>
   </figure>
  {% endlang_operator %}

  {% lang_operator RxScala slidingBuffer tumblingBuffer %}
   <p>
    RxScala has two varieties of <span class="operator">Buffer</span> &mdash;
    <code>slidingBuffer</code> and <code>tumblingBuffer</code> &mdash; each of which has variants
    with different ways of assembling the buffers they emit:
   </p>
   <h4><code>slidingBuffer(count, skip)</code></h4>
   <figure class="variant">
    <img src="images/slidingBuffer4.png" style="width:100%;" alt="slidingBuffer(count,skip)" />
    <figcaption>
     <p><code>slidingBuffer(count,&#8239;skip)</code> creates a new buffer starting with the first
        emitted item from the source Observable, and every <code>skip</code> items thereafter, and
        fills each buffer with <code>count</code> items: the initial item and <code>count-1</code>
        subsequent ones. It emits these buffers as <code>Seq</code>s. Depending on the values of
        <code>count</code> and <code>skip</code> these buffers may overlap (multiple buffers may
        contain the same item), or they may have gaps (where items emitted by the source
        Observable are not represented in any buffer).</p>
    </figcaption>
   </figure>
   <h4><code>slidingBuffer(timespan, timeshift)</code></h4>
   <figure class="variant">
    <img src="images/slidingBuffer7.png" style="width:100%;" alt="slidingBuffer(timespan,timeshift)" />
    <figcaption>
     <p><code>slidingBuffer(timespan,&#8239;timeshift)</code> creates a new
        <code>Seq</code> of items every <code>timeshift</code> (a <code>Duration</code>), and
        fills this buffer with every item emitted by the source Observable from that time until
        <code>timespan</code> (also a <code>Duration</code>) has passed since the buffer&#8217;s
        creation, before emitting this <code>Seq</code> as its own emission. If
        <code>timespan</code> is longer than <code>timeshift</code>, the emitted arrays will
        represent time periods that overlap and so they may contain duplicate items. There is also
        a version of this variant of the operator that takes a
        <a href="../scheduler.html"><code>Scheduler</code></a> as a parameter and uses it to govern the
        timespan.</p>
    </figcaption>
   </figure>
   <h4><code>slidingBuffer(openings, closings)</code></h4>
   <figure class="variant">
    <img src="images/slidingBuffer2.png" style="width:100%;" alt="slidingBuffer(openings,closings)" />
    <figcaption>
     <p><code>slidingBuffer(openings,closings)</code> monitors the <code>openings</code>
     Observable, and, whenever it emits an <code>Opening</code> item, <code>slidingBuffer</code>
     creates a new <code>Seq</code>, begins to collect items subsequently emitted by the source
     Observable into this buffer, and calls <code>closings</code> to get a new Observable to
     govern the closing of that buffer. When this new Observable emits an item or terminates,
     <code>slidingBuffer</code> closes and emits the <code>Seq</code>that the Observable
     governs.</p>
    </figcaption>
   </figure>
   <h4><code>tumblingBuffer(count)</code></h4>
   <figure class="variant">
    <img src="images/tumblingBuffer3.png" style="width:100%;" alt="tumblingBuffer(count)" />
    <figcaption>
     <p><code>tumblingBuffer(count)</code> emits non-overlapping buffers in the form of
        <code>Seq</code>s, each of which contains at most <code>count</code> items from the source
        Observable (the final emitted buffer may have fewer than <code>count</code> items).</p>
    </figcaption>
   </figure>
   <h4><code>tumblingBuffer(boundary)</code></h4>
   <figure class="variant">
    <img src="images/tumblingBuffer8.png" style="width:100%;" alt="tumblingBuffer(boundary)" />
    <figcaption>
     <p><code>tumblingBuffer(boundary)</code> monitors an Observable, <code>boundary</code>. Each
        time that Observable emits an item, it creates a new <code>Seq</code> to begin collecting
        items emitted by the source Observable and emits the previous <code>Seq</code>. This
        variant of the operator has an optional second parameter, <code>initialCapacity</code>
        with which you can indicate the expected size of these buffers so as to make memory
        allocation more efficient.</p>
    </figcaption>
   </figure>
   <h4><code>tumblingBuffer(timespan)</code></h4>
   <figure class="variant">
    <img src="images/tumblingBuffer5.png" style="width:100%;" alt="tumblingBuffer(timespan)" />
    <figcaption>
     <p><code>tumblingBuffer(timespan)</code> emits a new <code>Seq</code> of items periodically,
        every <code>timespan</code> (a <code>Duration</code>), containing all items emitted by the
        source Observable since the previous bundle emission or, in the case of the first bundle,
        since the subscription to the source Observable. This variant of the operator has an
        optional second parameter, <code>scheduler</code>, with which you can set the
        <a href="../scheduler.html"><code>Scheduler</code></a> that you want to govern the timespan
        calculation.</p>
    </figcaption>
   </figure>
   <h4><code>tumblingBuffer(timespan, count)</code></h4>
   <figure class="variant">
    <img src="images/tumblingBuffer6.png" style="width:100%;" alt="tumblingBuffer(timespan,count)" />
    <figcaption>
     <p><code>tumblingBuffer(timespan,&#8239;count)</code> emits a new <code>Seq</code> of items
        for every <code>count</code> items emitted by the source Observable, or, if
        <code>timespan</code> (a <code>Duration</code>) has elapsed since its last bundle
        emission, it emits a <code>Seq</code> containing however many items the source Observable
        emitted in that span, even if this is fewer than <code>count</code>. This variant of the
        operator has an optional third parameter, <code>scheduler</code>, with which you can set
        the <a href="../scheduler.html"><code>Scheduler</code></a> that you want to govern the timespan
        calculation.</p>
    </figcaption>
   </figure>
  {% endlang_operator %}

  {% lang_operator RxSwift buffer %}
     <p>
      <span style="color:#ff0000">TBD</span>
     </p>
  {% endlang_operator %}

</div>
