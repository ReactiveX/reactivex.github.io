---
layout: documentation
title: ReactiveX - Replay operator
id: replay
---

<ol class="breadcrumb">
  <li><a href="{{ site.url }}/documentation/operators.html">Operators</a></li>
  <li><a href="{{ site.url }}/documentation/operators.html#connectable">Connectable</a></li>
  <li class="active">Replay</li>
</ol>

<h1>Replay</h1>
<h3>ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items</h3>

<figure>
 <img src="images/replay.c.png" style="width:100%;" alt="Replay" />
 <figcaption><p>
  A <dfn>connectable Observable</dfn> resembles an ordinary Observable, except that it does not begin
  emitting items when it is subscribed to, but only when the <span class="operator">Connect</span>
  operator is applied to it. In this way you can prompt an Observable to begin emitting items at a
  time of your choosing.
 </p><p>
  If you apply the <span class="operator">Replay</span> operator to an Observable before you convert
  it into a connectable Observable, the resulting connectable Observable will always emit the same
  complete sequence to any future observers, even those observers that subscribe after the
  connectable Observable has begun to emit items to other subscribed observers.
 </p></figcaption>
</figure>

<h4>See Also</h4>
<ul>
 <li><a href="connect.html"><span class="operator">Connect</span></a></li>
 <li><a href="publish.html"><span class="operator">Publish</span></a></li>
 <li><a href="refcount.html"><span class="operator">RefCount</span></a></li>
 <li><a href="http://www.introtorx.com/Content/v1.0.10621.0/14_HotAndColdObservables.html#Replay"><cite>Introduction to Rx</cite>: Replay</a></li>
</ul>

<h2>Language-Specific Information:</h2>

<div class="panel-group operators-by-language" id="accordion" role="tablist" aria-multiselectable="true">

  {% lang_operator RxClojure cache %}
    <p> 
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxCpp publish_synchronized replay %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}
 
  {% lang_operator RxGroovy replay cache %}
    <figure class="variant">
     <img src="images/replay.png" style="width:100%;" alt="replay" />
     <figcaption><p>
      In RxGroovy there is a variety of the <code>replay</code> operator that returns a connectable
      Observable. You must <a href="publish.html"><span class="operator">Publish</span></a> this
      connectable Observable before observers can subscribe to it, and then
      <a href="connect.html"><span class="operator">Connect</span></a> to it in order to observe its
      emissions.
     </p><p>
      Variants of this variety of the <code>replay</code> operator permit you to set a maximum
      buffer size to limit the number of items <code>replay</code> will buffer and replay to
      subsequent observers, and/or to establish a moving time window that defines when emitted items
      become too old to buffer and replay.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay()"><code>replay()</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.Scheduler)"><code>replay(Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int)"><code>replay(int)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20rx.Scheduler)"><code>replay(int,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit)"><code>replay(long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(long,TimeUnit,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit)"><code>replay(int,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(int,long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/replay.f.png" style="width:100%;" alt="replay" />
     <figcaption><p>
      There is also a variety of <code>replay</code> that returns an ordinary Observable. These
      variants take as a parameter a transformative function; this function accepts an item emitted
      by the source Observable as its parameter, and returns an item to be emitted by the resulting
      Observable. So really, this operator does not replay the source Observable but instead replays
      the source Observable <em>as transformed</em> by this function.
     </p><p>
      Variants of this variety of the <code>replay</code> operator permit you to set a maximum
      buffer size to limit the number of items <code>replay</code> will buffer and replay to
      subsequent observers, and/or to establish a moving time window that defines when emitted items
      become too old to buffer and replay.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1)"><code>replay(Func1)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20rx.Scheduler)"><code>replay(Func1,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int)"><code>replay(Func1,int)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20rx.Scheduler)"><code>replay(Func1,int,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit)"><code>replay(Func1,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(Func1,long,TimeUnit,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit)"><code>replay(Func1,int,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(Func1,int,long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJava replay cache %}
    <figure class="variant">
     <img src="images/replay.png" style="width:100%;" alt="replay" />
     <figcaption><p>
      In RxJava there is a variety of the <code>replay</code> operator that returns a connectable
      Observable. You must <a href="publish.html"><span class="operator">Publish</span></a> this
      connectable Observable before observers can subscribe to it, and then
      <a href="connect.html"><span class="operator">Connect</span></a> to it in order to observe its
      emissions.
     </p><p>
      Variants of this variety of the <code>replay</code> operator permit you to set a maximum
      buffer size to limit the number of items <code>replay</code> will buffer and replay to
      subsequent observers, and/or to establish a moving time window that defines when emitted items
      become too old to buffer and replay.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay()"><code>replay()</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.Scheduler)"><code>replay(Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int)"><code>replay(int)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20rx.Scheduler)"><code>replay(int,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit)"><code>replay(long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(long,TimeUnit,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit)"><code>replay(int,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(int,long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
    <figure class="variant">
     <img src="images/replay.f.png" style="width:100%;" alt="replay" />
     <figcaption><p>
      There is also a variety of <code>replay</code> that returns an ordinary Observable. These
      variants take as a parameter a transformative function; this function accepts an item emitted
      by the source Observable as its parameter, and returns an item to be emitted by the resulting
      Observable. So really, this operator does not replay the source Observable but instead replays
      the source Observable <em>as transformed</em> by this function.
     </p><p>
      Variants of this variety of the <code>replay</code> operator permit you to set a maximum
      buffer size to limit the number of items <code>replay</code> will buffer and replay to
      subsequent observers, and/or to establish a moving time window that defines when emitted items
      become too old to buffer and replay.
     </p>
     <ul>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1)"><code>replay(Func1)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20rx.Scheduler)"><code>replay(Func1,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int)"><code>replay(Func1,int)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20rx.Scheduler)"><code>replay(Func1,int,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit)"><code>replay(Func1,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(Func1,long,TimeUnit,Scheduler)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit)"><code>replay(Func1,int,long,TimeUnit)</code></a></li>
      <li>Javadoc: <a href="http://reactivex.io/RxJava/javadoc/rx/Observable.html#replay(rx.functions.Func1,%20int,%20long,%20java.util.concurrent.TimeUnit,%20rx.Scheduler)"><code>replay(Func1,int,long,TimeUnit,Scheduler)</code></a></li>
     </ul></figcaption>
    </figure>
  {% endlang_operator %}

  {% lang_operator RxJS replay shareReplay %}
    <figure class="variant">
     <img src="images/replay.fnts.png" style="width:100%;" alt="replay" />
     <figcaption><p>
      In RxJs the <code>replay</code> operator takes four optional parameters and returns an
      ordinary Observable:
     </p>
     <dl>
      <dt><code>selector</code></dt><dd>a transforming function that takes an item emitted by the
          source Observable as its parameter and returns an item to be emitted by the resulting
          Observable</dd>
      <dt><code>bufferSize</code></dt><dd>the maximum number of items to buffer and replay to
          subsequent observers</dd>
      <dt><code>window</code></dt><dd>the age, in milliseconds, at which items in this buffer may be
          discarded without being emitted to subsequent observers</dd>
      <dt><code>scheduler</code></dt><dd>the <a href="../scheduler.html">Scheduler</a> on which this operator
          will operate</dd>
     </dl>
     <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var interval = Rx.Observable.interval(1000);

var source = interval
    .take(2)
    .do(function (x) {
        console.log('Side effect');
    });

var published = source
    .replay(function (x) {
        return x.take(2).repeat(2);
    }, 3);

published.subscribe(createObserver('SourceA'));
published.subscribe(createObserver('SourceB'));

function createObserver(tag) {
    return Rx.Observer.create(
        function (x) { console.log('Next: ' + tag + x); },
        function (err) { console.log('Error: ' + err); },
        function () { console.log('Completed'); });
}</pre></div><div class="output"><pre>
Side effect
Next: SourceA0
Side effect
Next: SourceB0
Side effect
Next: SourceA1
Next: SourceA0
Next: SourceA1
Completed
Side effect
Next: SourceB1
Next: SourceB0
Next: SourceB1
Completed</pre></div>
     </figcaption>
    </figure>
    <p>
     There is also a <code>shareReplay</code> operator, which keeps track of the number of
     observers, and disconnects from the source Observable when that number drops to zero.
     <code>shareReplay</code> takes three optional parameters and returns an ordinary Observable:
     </p>
     <dl>
      <dt><code>bufferSize</code></dt><dd>the maximum number of items to buffer and replay to
          subsequent observers</dd>
      <dt><code>window</code></dt><dd>the age, in milliseconds, at which items in this buffer may be
          discarded without being emitted to subsequent observers</dd>
      <dt><code>scheduler</code></dt><dd>the <a href="../scheduler.html">Scheduler</a> on which this operator
          will operate</dd>
     </dl>
    <h4>Sample Code</h4>
     <div class="code javascript"><pre>
var interval = Rx.Observable.interval(1000);

var source = interval
    .take(4)
    .doAction(function (x) {
        console.log('Side effect');
    });

var published = source
    .shareReplay(3);

published.subscribe(createObserver('SourceA'));
published.subscribe(createObserver('SourceB'));

// Creating a third subscription after the previous two subscriptions have
// completed. Notice that no side effects result from this subscription,
// because the notifications are cached and replayed.
Rx.Observable
    .return(true)
    .delay(6000)
    .flatMap(published)
    .subscribe(createObserver('SourceC'));

function createObserver(tag) {
    return Rx.Observer.create(
        function (x) { console.log('Next: ' + tag + x); },
        function (err) { console.log('Error: ' + err); },
        function () { console.log('Completed'); });
}</pre></div><div class="output"><pre>
Side effect
Next: SourceA0
Next: SourceB0
Side effect
Next: SourceA1
Next: SourceB1
Side effect
Next: SourceA2
Next: SourceB2
Side effect
Next: SourceA3
Next: SourceB3
Completed
Completed
Next: SourceC1
Next: SourceC2
Next: SourceC3
Completed</pre></div>
     <p>
      <code>replay</code> and <code>shareReplay</code> are found in the following distributions:
     </p>
     <ul>
      <li><code>rx.all.js</code></li>
      <li><code>rx.all.compat.js</code></li>
      <li><code>rx.binding.js</code> (requires <code>rx.js</code> or <code>rx.compat.js</code>)</li>
      <li><code>rx.lite.js</code></li>
      <li><code>rx.lite.compat.js</code></li>
     </ul>
  {% endlang_operator %}

  {% lang_operator RxKotlin replay cache %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator Rx.NET Replay %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxPHP replay shareReplay %}
<figure class="variant">
    <figcaption>
    <p>
    RxPHP implements this operator as <code>replay</code>.
    </p>
    <p>
    Returns an observable sequence that is the result of invoking the selector on a connectable observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.  This operator is a specialization of Multicast using a ReplaySubject.
    </p>
<h4>Sample Code</h4>
<div class="code php">
    <pre>
//from https://github.com/ReactiveX/RxPHP/blob/master/demo/replay/replay.php

$loop      = \React\EventLoop\Factory::create();
$scheduler = new \Rx\Scheduler\EventLoopScheduler($loop);

$interval = \Rx\Observable::interval(1000);

$source = $interval
    ->take(2)
    ->doOnNext(function ($x) {
        echo $x, " something", PHP_EOL;
        echo "Side effect", PHP_EOL;
    });

$published = $source
    ->replay(function (\Rx\Observable $x) {
        return $x->take(2)->repeat(2);
    }, 3);

$published->subscribe($createStdoutObserver('SourceA '), $scheduler);
$published->subscribe($createStdoutObserver('SourceB '), $scheduler);

$loop->run();

   </pre>
</div>
<div class="output">
    <pre>

    </pre>
</div>
    </figcaption>
</figure><figure class="variant">
    <figcaption>
    <p>
    RxPHP also has an operator <code>shareReplay</code>.
    </p>
    <p>
    Returns an observable sequence that shares a single subscription to the underlying sequence replaying notifications subject to a maximum time length for the replay buffer.  This operator is a specialization of  replay which creates a subscription when the number of observers goes from zero to one, then shares that  subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
    </p>
<h4>Sample Code</h4>
<div class="code php">
    <pre>
//from https://github.com/ReactiveX/RxPHP/blob/master/demo/share/shareReplay.php

$loop      = \React\EventLoop\Factory::create();
$scheduler = new \Rx\Scheduler\EventLoopScheduler($loop);

$interval = Rx\Observable::interval(1000);

$source = $interval
    ->take(4)
    ->doOnNext(function ($x) {
        echo 'Side effect', PHP_EOL;
    });

$published = $source
    ->shareReplay(3);

$published->subscribe($createStdoutObserver('SourceA '), $scheduler);
$published->subscribe($createStdoutObserver('SourceB '), $scheduler);

Rx\Observable
    ::just(true)
    ->concatMapTo(\Rx\Observable::timer(6000))
    ->flatMap(function () use ($published) {
        return $published;
    })
    ->subscribe($createStdoutObserver('SourceC '), $scheduler);

$loop->run();


   </pre>
</div>
<div class="output">
    <pre>
Side effect
SourceA Next value: 0
SourceB Next value: 0
Side effect
SourceA Next value: 1
SourceB Next value: 1
Side effect
SourceA Next value: 2
SourceB Next value: 2
Side effect
SourceA Next value: 3
SourceB Next value: 3
SourceA Complete!
SourceB Complete!
SourceC Next value: 1
SourceC Next value: 2
SourceC Next value: 3
SourceC Complete!
    </pre>
</div>
    </figcaption>
</figure>
  {% endlang_operator %}

  {% lang_operator RxPY replay %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator Rx.rb %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxScala replay cache %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

  {% lang_operator RxSwift replay shareReplay %}
    <p>
     <span style="color:#f00">TBD</span>
    </p>
  {% endlang_operator %}

</div>
