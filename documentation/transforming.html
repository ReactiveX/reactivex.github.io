<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ReactiveX - Transforming Observables</title>

    <!-- Polymer -->
    <script src="/polymer/components/platform/platform.js"></script>

    <!-- Bootstrap -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">

    <!-- Prism -->
    <link href="/css/prism.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <style shim-shadowdom>
        /* This is overriding our styles for body, and it shouldn't.
        body {
          font-family: RobotoDraft, 'Helvetica Neue', Helvetica, Arial;
          color: #333;
          -webkit-user-select: none;
          -moz-user-select: none;
          -ms-user-select: none;
          user-select: none;
          -webkit-tap-highlight-color: rgba(0,0,0,0);
          -webkit-touch-callout: none;
        }
        */

        paper-tabs, core-toolbar {
          background-color: #00bcd4;
          color: #fff;
          box-shadow: 0px 3px 2px rgba(0, 0, 0, 0.2);
        }

        core-toolbar paper-tabs {
          box-shadow: none;
        }

        paper-tabs[noink][nobar] paper-tab.core-selected {
          color: #ffff8d;
        }

        paper-tabs.transparent-teal {
          background-color: transparent;
          color: #00bcd4;
          box-shadow: none;
        }

        paper-tabs.transparent-teal::shadow #selectionBar {
          background-color: #00bcd4;
        }

        paper-tabs.transparent-teal paper-tab::shadow #ink {
          color: #00bcd4;
        }

        /* This is overriding our custom styles, and it shouldn't.
        h3 {
          font-size: 16px;
          font-weight: 400;
        }
        */
    </style>
  </head>
  <body>
    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><img src="/assets/Rx_Icon.png" style="height:90%;"/> ReactiveX</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a href="/intro.html">Introduction</a></li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Docs <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <li><a href="/documentation.html">Getting Started</a></li>
<li><a href="/documentation/observable.html">Observable</a></li>
<li><a href="/documentation/operators.html">Operators</a></li>
<li><a href="/documentation/subject.html">Subject</a></li>
<li><a href="/documentation/scheduler.html">Scheduler</a></li>
<li><a href="/documentation/backpressure.html">Backpressure</a></li>
<li><a href="/documentation/errors.html">Error handling</a></li>

              </ul>
            </li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Languages <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <li><a href="https://github.com/ReactiveX/RxJava">RxJava<span class="external-link"></span></a></li>
<li><a href="https://github.com/Reactive-Extensions/RxJS">RxJS<span class="external-link"></span></a></li>
<li><a href="https://github.com/Reactive-Extensions/Rx.NET">Rx.NET<span class="external-link"></span></a></li>
<li><a href="/rxscala">RxScala</a></li>
<li><a href="https://github.com/ReactiveX/RxClojure">RxClojure<span class="external-link"></span></a></li>
<li><a href="/languages.html">Others</a></li>

              </ul>
            </li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Resources <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <li><a href="/tutorials.html">Tutorials</a></li>
<!-- Uncomment only when ready
<li><a href="/releases.html">Releases and Binaries</a></li>
<li><a href="#">Code samples</a></li>
<li><a href="#">Presentations</a></li>
<li><a href="#">Related Projects</a></li>
<li><a href="#">Who uses Rx</a></li>
 -->

              </ul>
            </li>

            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">
                Community <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                <li><a href="https://github.com/ReactiveX">GitHub<span class="external-link"></span></a></li>
<li><a href="https://twitter.com/ReactiveX">Twitter<span class="external-link"></span></a></li>
<li><a href="/community.html">Others</a></li>

              </ul>
            </li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="/js/jquery/1.11.0/jquery.min.js"></script>

    <div class="site-content">
      <style>
/* make sidebar nav vertical */
@media (min-width: 768px) {
  .side-menu {
    padding-top: 20px;
    padding-bottom: 20px;
    padding-right: 20px;
    max-height: none;
    border: 1px solid #DDD;
  }
}
</style>

<div class="full-page-container">
  <div class="row">
    <div class="col-sm-8">
      <h1 id="transforming-observables">Transforming Observables</h1>

<p>This section explains operators with which you can transform items that are emitted by an Observable.</p>

<ul>
<li><a href="Transforming-Observables#map"><strong><code>map( )</code></strong></a> — transform the items emitted by an Observable by applying a function to each of them</li>
<li><a href="Transforming-Observables#flatmap"><strong><code>flatMap( )</code></strong></a> — transform the items emitted by an Observable into Observables, then flatten this into a single Observable</li>
<li><a href="Transforming-Observables#mergemap-and-mergemapiterable"><strong><code>mergeMap( )</code> and <code>mergeMapIterable( )</code></strong></a> — create Observables (or Iterables) corresponding to each emission from a source Observable and merge the results into a single Observable</li>
<li><a href="Transforming-Observables#scan"><strong><code>scan( )</code></strong></a> — apply a function to each item emitted by an Observable, sequentially, and emit each successive value</li>
<li><a href="Transforming-Observables#groupby-and-groupbyuntil"><strong><code>groupBy( )</code> and <code>groupByUntil( )</code></strong></a> — divide an Observable into a set of Observables that emit groups of items from the original Observable, organized by key</li>
<li><a href="Transforming-Observables#pivot"><strong><code>pivot( )</code></strong></a> — combine multiple sets of grouped observables so that they are arranged primarily by group rather than by set</li>
<li><a href="Transforming-Observables#buffer"><strong><code>buffer( )</code></strong></a> — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time </li>
<li><a href="Transforming-Observables#window"><strong><code>window( )</code></strong></a> — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time </li>
<li><a href="Transforming-Observables#cast"><strong><code>cast( )</code></strong></a> — cast all items from the source Observable into a particular type before reemitting them</li>
</ul>

<hr>

<h2 id="map( )">map( )</h2>

<h4 id="transform-the-items-emitted-by-an-observable-by-applying-a-function-to-each-of-them">transform the items emitted by an Observable by applying a function to each of them</h4>

<p><img src="/assets/operators/map.png" width="640" height="305" />​</p>

<p>The <code>map( )</code> method applies a function of your choosing to every item emitted by an Observable, and returns this transformation as a new Observable. For example, the following code maps a function that squares the incoming value onto the values in <code>numbers</code>:</p>
<div class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">numbers</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">([</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]);</span>

<span class="n">numbers</span><span class="o">.</span><span class="na">map</span><span class="o">({</span><span class="n">it</span> <span class="o">*</span> <span class="n">it</span><span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">);</span> <span class="o">},</span>                          <span class="c1">// onNext</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="o">},</span> <span class="c1">// onError</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Sequence complete&quot;</span><span class="o">);</span> <span class="o">}</span>          <span class="c1">// onCompleted</span>
<span class="o">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">1
4
9
16
25
Sequence complete
</code></pre></div>
<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#map(rx.functions.Func1)"><code>map(func)</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg"><code>map</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.select.aspx"><code>Select</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#Select">Introduction to Rx: Select</a></li>
</ul>

<hr>

<h2 id="flatmap( )">flatMap( )</h2>

<h4 id="transform-the-items-emitted-by-an-observable-into-observables,-then-flatten-this-into-a-single-observable">Transform the items emitted by an Observable into Observables, then flatten this into a single Observable</h4>

<p><img src="/assets/operators/flatMap.png" width="640" height="310" />​</p>

<p>The <code>flatMap( )</code> method creates a new Observable by applying a function that you supply to each item emitted by the original Observable, where that function is itself an Observable that emits items, and then merges the results of that function applied to every item emitted by the original Observable, emitting these merged results.</p>

<p>This method is useful, for example, when you have an Observable that emits a series of items that themselves have Observable members or are in other ways transformable into Observables, so that you can create a new Observable that emits the complete collection of items emitted by the sub-Observables of these items.</p>
<div class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="c1">// this closure is an Observable that emits three numbers</span>
<span class="n">numbers</span>   <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">([</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]);</span>
<span class="c1">// this closure is an Observable that emits two numbers based on what number it is passed</span>
<span class="n">multiples</span> <span class="o">=</span> <span class="o">{</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">([</span> <span class="n">n</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">n</span><span class="o">*</span><span class="mi">3</span> <span class="o">])</span> <span class="o">};</span>   

<span class="n">numbers</span><span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="n">multiples</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">);</span> <span class="o">},</span>                          <span class="c1">// onNext</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="o">},</span> <span class="c1">// onError</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Sequence complete&quot;</span><span class="o">);</span> <span class="o">}</span>          <span class="c1">// onCompleted</span>
<span class="o">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">2
3
4
6
6
9
Sequence complete
</code></pre></div>
<p>If any of the individual Observables mapped to the items from the source Observable in <code>flatMap( )</code> aborts by invoking <code>onError</code>, the <code>flatMap( )</code> call itself will immediately abort and invoke <code>onError</code>.</p>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#flatMap(rx.functions.Func1)"><code>flatMap</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeselectmanyselector-resultselector"><code>selectMany</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.selectmany.aspx"><code>SelectMany</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#SelectMany">Introduction to Rx: SelectMany</a></li>
</ul>

<hr>

<h2 id="mergemap( )-and-mergemapiterable( )">mergeMap( ) and mergeMapIterable( )</h2>

<h4 id="create-observables-(or-iterables)-corresponding-to-each-emission-from-a-source-observable-and-merge-the-results-into-a-single-observable">create Observables (or Iterables) corresponding to each emission from a source Observable and merge the results into a single Observable</h4>

<p><img width="640" height="410" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMap.nce.png" /></p>

<p><code>mergeMap( )</code> at its most basic is an alias for <code>flatMap( )</code>, but it also has some variants that <code>flatMap( )</code> lacks. For example, one version (the one illustrated in the marble diagram above) creates (and merges) a new Observable for each item <em>and notification</em> from the source Observable.</p>

<p>Another version combines items from the source Observable with the items emitted by an Observable triggered by those source items, and emits these combinations:</p>

<p><img width="640" height="390" src="https://raw.github.com/wiki/Netflix/RxJava/images/rx-operators/mergeMap.r.png"></p>

<p>The <code>mergeMapIterable</code> variants pair up source items and generated Iterables rather than source items and generated Observables, but otherwise work in much the same way.</p>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#mergeMap(rx.functions.Func1)"><code>mergeMap(observableFactory)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#mergeMap(rx.functions.Func1, rx.functions.Func1, rx.functions.Func0)"><code>mergeMap(onNextObservableFactory, onErrorObservableFactory, onCompletedObservableFactory)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#mergeMap(rx.functions.Func1, rx.functions.Func2)"><code>mergeMap(collectionSelector, resultSelector)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#mergeMapIterable(rx.functions.Func1)"><code>mergeMapIterable(collectionSelector)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#mergeMapIterable(rx.functions.Func1, rx.functions.Func2)"><code>mergeMapIterable(collectionSelector, resultSelector)</code></a></li>
</ul>

<hr>

<h2 id="scan( )">scan( )</h2>

<h4 id="apply-a-function-to-each-item-emitted-by-an-observable-and-emit-each-successive-value">Apply a function to each item emitted by an Observable and emit each successive value</h4>

<p><img src="/assets/operators/scan.png" width="640" height="320" />​</p>

<p>The <code>scan( )</code> method returns an Observable that applies a function of your choosing to the first item emitted by a source Observable, then feeds the result of that function along with the second item emitted by the source Observable into the same function, then feeds the result of that function along with the third item into the same function, and so on until all items have been emitted by the source Observable. It emits the result of each of these iterations from the returned Observable. This sort of function is sometimes called an “accumulator.”</p>

<p>For example, the following code takes an Observable that emits a consecutive sequence of <em>n</em> integers starting with 1 and converts it into an Observable that emits the first <em>n</em> <a href="http://en.wikipedia.org/wiki/Triangular_number">triangular numbers</a>:</p>
<div class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">numbers</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">([</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">]);</span>

<span class="n">numbers</span><span class="o">.</span><span class="na">scan</span><span class="o">({</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">}).</span><span class="na">subscribe</span><span class="o">(</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">);</span> <span class="o">},</span>                          <span class="c1">// onNext</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="o">},</span> <span class="c1">// onError</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Sequence complete&quot;</span><span class="o">);</span> <span class="o">}</span>          <span class="c1">// onCompleted</span>
<span class="o">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">1
3
6
10
15
Sequence complete
</code></pre></div>
<p>There is also a version of <code>scan( )</code> to which you can pass a seed item in addition to an accumulator function:</p>
<div class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">my_observable</span><span class="o">.</span><span class="na">scan</span><span class="o">(</span><span class="n">initial_seed</span><span class="o">,</span> <span class="n">accumulator_closure</span><span class="o">)</span>
</code></pre></div>
<p><strong>Note:</strong> if you pass a seed item to <code>scan( )</code>, it will emit the seed itself as its first item.</p>

<p>Note also that passing a <code>null</code> seed is not the same as not passing a seed. The behavior will be different. If you pass a seed of <code>null</code>, you will be seeding your scan with <code>null</code>, and <code>scan( )</code> will emit <code>null</code> as its first item.</p>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#scan(rx.functions.Func2)"><code>scan(accumulator)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#scan(R, rx.functions.Func2)"><code>scan(initialValue, accumulator)</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypescanseed-accumulator"><code>scan</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.scan.aspx"><code>Scan</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#Scan">Introduction to Rx: Scan</a></li>
</ul>

<hr>

<h2 id="groupby( )-and-groupbyuntil( )">groupBy( ) and groupByUntil( )</h2>

<h4 id="divide-an-observable-into-a-set-of-observables-that-emit-groups-of-items-from-the-original-observable,-organized-by-key">divide an Observable into a set of Observables that emit groups of items from the original Observable, organized by key</h4>

<p><img src="/assets/operators/groupBy.png" width="640" height="360" />​</p>

<p>The <code>groupBy( )</code> method creates or extracts a key from all of the items emitted by a source Observable. For each unique key created in this way, <code>groupBy( )</code> creates an Observable of the subclass <a href="http://netflix.github.io/RxJava/javadoc/rx/observables/GroupedObservable.html"><code>GroupedObservable</code></a> that emits all of the items emitted by the source Observable that match that key. <code>groupBy( )</code> then emits each of these <code>GroupedObservable</code> items. Each Observable of this subclass has a method, <a href="http://netflix.github.io/RxJava/javadoc/rx/observables/GroupedObservable.html#getKey()"><code>getKey( )</code></a> with which you can retrieve the key that defined the <code>GroupedObservable</code>.</p>

<p>The following sample code uses <code>groupBy( )</code> to transform a list of numbers into two lists, grouped by whether or not the numbers are even:
```groovy
def numbers = Observable.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
def groupFunc = { return(0 == (it % 2)); };</p>

<p>numbers.groupBy(groupFunc).flatMap({ it.reduce([it.getKey()], {a, b -&gt; a &lt;&lt; b}) }).subscribe(
  { println(it); },                          // onNext
  { println(&quot;Error: &quot; + it.getMessage()); }, // onError
  { println(&quot;Sequence complete&quot;); }          // onCompleted
);
<code>
</code>
[false, 1, 3, 5, 7, 9]
[true, 2, 4, 6, 8]
Sequence complete
```</p>

<p>There is also a <code>groupByUntil( )</code> operator. It adds another parameter: an Observable that emits duration markers. When a duration marker is emitted by this Observable, any grouped Observables that have been opened are closed, and <code>groupByUntil( )</code> will create new grouped Observables for any subsequent emissions by the source Observable.</p>

<p><img src="/assets/operators/groupByUntil.png" width="640" height="375" />​</p>

<p>Another variety of <code>groupByUntil( )</code> limits the number of groups that can be active at any particular time. If an item is emitted by the source Observable that would cause the number of groups to exceed this maximum, before the new group is emitted, one of the existing groups is closed (that is, the Observable it represents terminates by calling its Subscribers&#39; <code>onCompleted</code> methods and then expires).</p>

<p>Note that when <code>groupBy( )</code> or <code>groupByUntil( )</code> splits up the source Observable into an Observable that emits GroupedObservables, each of these GroupedObservables begins to buffer the items that it will emit upon subscription. For this reason, if you ignore any of these GroupedObservables (you neither subscribe to it or apply an operator to it that subscribes to it), this buffer will present a potential memory leak.  For this reason, rather than ignoring a GroupedObservable that you have no interest in observing, you should instead apply an operator like <code>take(0)</code> to it as a way of signalling to it that it may discard its buffer.</p>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#groupBy(rx.functions.Func1)"><code>groupBy(keySelector)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#groupByUntil(rx.functions.Func1, rx.functions.Func1)"><code>groupByUntil(keySelector, durationSelector)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#groupByUntil(rx.functions.Func1, rx.functions.Func1, rx.functions.Func1)"><code>groupByUntil(keySelector, valueSelector, durationSelector)</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypegroupbykeyselector-elementselector-keyserializer"><code>groupBy</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypegroupbyuntilkeyselector-elementselector-durationselector-keyserializer"><code>groupByUntil</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.groupby.aspx"><code>GroupBy</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.groupbyuntil.aspx"><code>GroupByUntil</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/07_Aggregation.html#GroupBy">Introduction to Rx: GroupBy</a></li>
</ul>

<hr>

<h2 id="pivot( )">pivot( )</h2>

<h4 id="combine-multiple-sets-of-grouped-observables-so-that-they-are-arranged-primarily-by-group-rather-than-by-set">combine multiple sets of grouped observables so that they are arranged primarily by group rather than by set</h4>

<p><img src="/assets/operators/pivot.png" width="640" height="580" />​</p>

<p>If you combine multiple sets of grouped observables, such as those created by <a href="Transforming-Observables#wiki-groupby-and-groupbyuntil"><code>groupBy( )</code> and <code>groupByUntil( )</code></a>, then even if those grouped observables have been grouped by a similar differentiation function, the resulting grouping will be primarily based on which set the observable came from, not on which group the observable belonged to.</p>

<p>An example may make this clearer. Imagine you use <code>groupBy( )</code> to group the emissions of an Observable (Observable1) that emits integers into two grouped observables, one emitting the even integers and the other emitting the odd integers. You then repeat this process on a second Observable (Observable2) that emits another set of integers. You hope then to combine the sets of grouped observables emitted by each of these into a single grouped Observable by means of a operator like <code>from( Observable1, Observable2 )</code>.</p>

<p>The result will be a grouped observable that emits two groups: the grouped observable resulting from transforming Observable1, and the grouped observable resulting from transforming Observable2. Each of those grouped observables emit observables that in turn emit the odds and evens from the source observables. You can use <code>pivot( )</code> to change this around: by applying <code>pivot( )</code> to this grouped observable it will transform into one that emits two different groups: the odds group and the evens group, with each of these groups emitting a separate observable corresponding to which source observable its set of integers came from. Here is an illustration:</p>

<p><img src="/assets/operators/pivot.ex.png" width="640" height="1140" />​</p>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#pivot(rx.Observable)"><code>pivot(observable)</code></a></li>
</ul>

<hr>

<h2 id="buffer( )">buffer( )</h2>

<h4 id="periodically-gather-items-emitted-by-an-observable-into-bundles-and-emit-these-bundles-rather-than-emitting-the-items-one-at-a-time">periodically gather items emitted by an Observable into bundles and emit these bundles rather than emitting the items one at a time</h4>

<p><img src="/assets/operators/buffer.png" width="640" height="320" />​</p>

<p>The <code>buffer( )</code> method periodically gathers items emitted by a source <code>Observable</code> into bundles, and emits these bundles as its own emissions.</p>

<p>Note that if the source <code>Observable</code> issues an <code>onError</code> notification, <code>buffer( )</code> will pass on this notification immediately without first emitting the buffer it is in the process of assembling, even if that buffer contains items that were emitted by the source <code>Observable</code> before it issued the error notification.</p>

<p>There are a number of ways with which you can regulate how <code>buffer( )</code> gathers items from the source <code>Observable</code> into bundles:</p>

<ul>
<li><p><code>buffer(bufferOpenings, closingSelector)</code>
<br /><img src="/assets/operators/buffer2.png" width="610" height="448" />​</p>

<blockquote>
<p>This version of <code>buffer( )</code> monitors an <code>Observable</code>, <em>bufferOpenings</em>, that emits <code>BufferOpening</code> objects. Each time it observes such an emitted object, it creates a new bundle to begin collecting items emitted by the source <code>Observable</code> and it passes the <em>bufferOpenings</em> <code>Observable</code> into the <em>closingSelector</em> function. That function returns an <code>Observable</code>. <code>buffer( )</code> monitors that <code>Observable</code> and when it detects an emitted object, it closes its bundle and emits it as its own emission.</p>
</blockquote></li>
<li><p><code>buffer(count)</code>
<br /><img src="/assets/operators/buffer3.png" width="610" height="305" />​</p>

<blockquote>
<p>This version of <code>buffer( )</code> emits a new bundle of items for every <em>count</em> items emitted by the source <code>Observable</code>.</p>
</blockquote></li>
</ul>
<div class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="kt">def</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">([</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">]);</span>

<span class="n">numbers</span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="mi">3</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">);</span> <span class="o">},</span>                          <span class="c1">// onNext</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="o">},</span> <span class="c1">// onError</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Sequence complete&quot;</span><span class="o">);</span> <span class="o">}</span>          <span class="c1">// onCompleted</span>
<span class="o">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">[1, 2, 3]
[4, 5, 6]
[7, 8]
</code></pre></div>
<ul>
<li><code>buffer(count, skip)</code>
<br /><img src="/assets/operators/buffer4.png" width="610" height="305" />​
&gt; This version of <code>buffer( )</code> create a new bundle of items for every <em>skip</em> item(s) emitted by the source <code>Observable</code>, each containing <em>count</em> elements. If <em>skip</em> is less than <em>count</em> this means that the bundles will overlap and contain duplicate items. For example, compare the following two uses of <code>buffer( )</code> on the same sequence:</li>
</ul>
<div class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="kt">def</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">from</span><span class="o">([</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">]);</span>

<span class="n">numbers</span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">);</span> <span class="o">},</span>                          <span class="c1">// onNext</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="o">},</span> <span class="c1">// onError</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Sequence complete&quot;</span><span class="o">);</span> <span class="o">}</span>          <span class="c1">// onCompleted</span>
<span class="o">);</span>
<span class="n">numbers</span><span class="o">.</span><span class="na">buffer</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">).</span><span class="na">subscribe</span><span class="o">(</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">);</span> <span class="o">},</span>                          <span class="c1">// onNext</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Error: &quot;</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span> <span class="o">},</span> <span class="c1">// onError</span>
  <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s2">&quot;Sequence complete&quot;</span><span class="o">);</span> <span class="o">}</span>          <span class="c1">// onCompleted</span>
<span class="o">);</span>
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">[1, 2]
[4, 5]
[7, 8]
Sequence complete
[1, 2, 3]
[3, 4, 5]
[5, 6, 7]
[7, 8]
Sequence complete
</code></pre></div>
<ul>
<li><p><code>buffer(timespan)</code> and <code>buffer(timespan, scheduler)</code>
<br /><img src="/assets/operators/buffer5.png" width="610" height="305" />​</p>

<blockquote>
<p>This version of <code>buffer( )</code> emits a new bundle of items periodically, every <em>timespan</em> amount of time, containing all items emitted by the source <code>Observable</code> since the previous bundle emission.</p>
</blockquote></li>
<li><p><code>buffer(timespan, count)</code> and <code>buffer(timespan, count, scheduler)</code>
<br /><img src="/assets/operators/buffer6.png" width="610" height="305" />​</p>

<blockquote>
<p>This version of <code>buffer( )</code> emits a new bundle of items for every <em>count</em> items emitted by the source <code>Observable</code>, or, if <em>timespan</em> has elapsed since its last bundle emission, it emits a bundle of however many items the source <code>Observable</code> has emitted in that span, even if this is less than <em>count</em>.</p>
</blockquote></li>
<li><p><code>buffer(timespan, timeshift)</code> and <code>buffer(timespan, timeshift, scheduler)</code>
<br /><img src="/assets/operators/buffer7.png" width="610" height="305" />​</p>

<blockquote>
<p>This version of <code>buffer( )</code> creates a new bundle of items every <em>timeshift</em>, and fills this bundle with every item emitted by the source <code>Observable</code> from that time until <em>timespan</em> time has passed since the bundle&#39;s creation, before emitting the bundle as its own emission. If <em>timespan</em> is longer than <em>timeshift</em>, the emitted bundles will represent time periods that overlap and so they may contain duplicate items.</p>
</blockquote></li>
</ul>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(rx.functions.Func0)"><code>buffer(closingSelector)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(int)"><code>buffer(count)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(int, int)"><code>buffer(count, skip)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(long, long, java.util.concurrent.TimeUnit)"><code>buffer(timespan, timeshift, unit)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><code>buffer(timespan, timeshift, unit, scheduler)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit)"><code>buffer(timespan, unit)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><code>buffer(timespan, unit, scheduler)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, int)"><code>buffer(timespan, unit, count)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(long, java.util.concurrent.TimeUnit, int, rx.Scheduler)"><code>buffer(timespan, unit, count, scheduler)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#buffer(rx.Observable, rx.functions.Func1)"><code>buffer(bufferOpenings, closingSelector)</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypebufferbufferopenings-bufferboundaries-bufferclosingselector"><code>buffer</code></a>, <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypebufferwithcountcount-skip"><code>bufferWithCount</code></a>, <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypebufferwithtimetimespan-timeshift--scheduler-scheduler"><code>bufferWithTime</code></a>, and <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypebufferwithtimeorcounttimespan-count-scheduler"><code>bufferWithTimeOrCount</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.buffer.aspx"><code>Buffer</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/13_TimeShiftedSequences.html#Buffer">Introduction to Rx: Buffer</a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#BufferRevisted">Introduction to Rx: Buffer revisited</a></li>
</ul>

<hr>

<h2 id="window( )">window( )</h2>

<h4 id="periodically-subdivide-items-from-an-observable-into-observable-windows-and-emit-these-windows-rather-than-emitting-the-items-one-at-a-time">periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</h4>

<p><img src="/assets/operators/window.png" width="640" height="400" />​</p>

<p>Window is similar to <code>buffer( )</code>, but rather than emitting packets of items from the original <code>Observable</code>, it emits <code>Observable</code>s, each one of which emits a subset of items from the original <code>Observable</code> and then terminates with an <code>onCompleted( )</code> call.</p>

<p>Like <code>buffer( )</code>, <code>window( )</code> has many varieties, each with its own way of subdividing the original <code>Observable</code> into the resulting <code>Observable</code> emissions, each one of which contains a &quot;window&quot; onto the original emitted items. In the terminology of the <code>window( )</code> method, when a window &quot;opens,&quot; this means that a new <code>Observable</code> is emitted and that <code>Observable</code> will begin emitting items emitted by the source <code>Observable</code>. When a window &quot;closes,&quot; this means that the emitted <code>Observable</code> stops emitting items from the source <code>Observable</code> and calls its Subscribers&#39; <code>onCompleted( )</code> method and terminates.</p>

<ul>
<li><p><code>window(source, closingSelector)</code>
<br /><img src="/assets/operators/window1.png" width="610" height="462" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens its first window immediately. It closes the currently open window and immediately opens a new one each time it observes an object emitted by the <code>Observable</code> that is returned from <em>closingSelector</em>. In this way, this version of <code>window( )</code> emits a series of non-overlapping windows whose collective <code>onNext( )</code> emissions correspond one-to-one with those of the <em>source</em> <code>Observable</code>.</p>
</blockquote></li>
<li><p><code>window(source, windowOpenings, closingSelector)</code>
<br /><img src="/assets/operators/window2.png" width="610" height="524" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens a window whenever it observes the <em>windowOpenings</em> <code>Observable</code> emit an <code>Opening</code> object and at the same time calls <em>closingSelector</em> to generate a closing <code>Observable</code> associated with that window. When that closing <code>Observable</code> emits an object, <code>window( )</code> closes that window. Since the closing of currently open windows and the opening of new windows are activities that are regulated by independent <code>Observable</code>s, this version of <code>window( )</code> may create windows that overlap (duplicating items from the <em>source</em> <code>Observable</code>) or that leave gaps (discarding items from the <em>source</em> <code>Observable</code>).</p>
</blockquote></li>
<li><p><code>window(source, count)</code>
<br /><img src="/assets/operators/window3.png" width="610" height="381" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens its first window immediately. It closes the currently open window and immediately opens a new one whenever the current window has emitted <em>count</em> items. It will also close the currently open window if it receives an <code>onCompleted( )</code> or <code>onError( )</code> call from the <em>source</em> <code>Observable</code>. This version of <code>window( )</code> emits a series of non-overlapping windows whose collective <code>onNext( )</code> emissions correspond one-to-one with those of the <em>source</em> <code>Observable</code>.</p>
</blockquote></li>
<li><p><code>window(source, count, skip)</code>
<br /><img src="/assets/operators/window4.png" width="610" height="348" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens its first window immediately. It opens a new window beginning with every <em>skip</em> item from the source <code>Observable</code> (e.g. if <em>skip</em> is 3, then it opens a new window starting with every third item). It closes each window when that window has emitted <em>count</em> items or if it receives an <code>onCompleted( )</code> or <code>onError( )</code> call from the <em>source</em> <code>Observable</code>. If <em>skip</em> = <em>count</em> then this behaves the same as <code>window(source, count)</code>; if <em>skip</em> &lt; <em>count</em> this will emit windows that overlap by <em>count</em> - <em>skip</em> items; if <em>skip</em> &gt; <em>count</em> this will emit windows that drop <em>skip</em> - <em>count</em> items from the <em>source</em> <code>Observable</code> between every window.</p>
</blockquote></li>
<li><p><code>window(source, timespan, unit)</code> and <code>window(source, timespan, unit, scheduler)</code>
<br /><img src="/assets/operators/window5.png" width="610" height="357" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens its first window immediately. It closes the currently open window and opens another one every <em>timespan</em> period of time (measured in <em>unit</em>, and optionally on a particular <em>scheduler</em>). It will also close the currently open window if it receives an <code>onCompleted( )</code> or <code>onError( )</code> call from the <em>source</em> <code>Observable</code>. This version of <code>window( )</code> emits a series of non-overlapping windows whose collective <code>onNext( )</code> emissions correspond one-to-one with those of the <em>source</em> <code>Observable</code>.</p>
</blockquote></li>
<li><p><code>window(source, timespan, unit, count)</code> and <code>window(source, timespan, unit, count, scheduler)</code>
<br /><img src="/assets/operators/window6.png" width="610" height="353" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens its first window immediately. It closes the currently open window and opens another one every <em>timespan</em> period of time (measured in <em>unit</em>, and optionally on a particular <em>scheduler</em>) or whenever the currently open window has emitted <em>count</em> items. It will also close the currently open window if it receives an <code>onCompleted( )</code> or <code>onError( )</code> call from the <em>source</em> <code>Observable</code>. This version of <code>window( )</code> emits a series of non-overlapping windows whose collective <code>onNext( )</code> emissions correspond one-to-one with those of the <em>source</em> <code>Observable</code>.</p>
</blockquote></li>
<li><p><code>window(source, timespan, timeshift, unit)</code> and <code>window(source, timespan, timeshift, unit, scheduler)</code>
<br /><img src="/assets/operators/window7.png" width="610" height="319" />​</p>

<blockquote>
<p>This version of <code>window( )</code> opens its first window immediately, and thereafter opens a new window every <em>timeshift</em> period of time (measured in <em>unit</em>, and optionally on a particular <em>scheduler</em>). It closes a currently open window after <em>timespan</em> period of time has passed since that window was opened. It will also close any currently open window if it receives an <code>onCompleted( )</code> or <code>onError( )</code> call from the <em>source</em> <code>Observable</code>. Depending on how you set <em>timespan</em> and <em>timeshift</em> the windows that result from this operation may overlap or have gaps.</p>
</blockquote></li>
</ul>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(rx.functions.Func0)"><code>window(closingSelector)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(int)"><code>window(count)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(int, int)"><code>window(count, skip)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(long, long, java.util.concurrent.TimeUnit)"><code>window(timespan, timeshift, unit)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(long, long, java.util.concurrent.TimeUnit, rx.Scheduler)"><code>window(timespan, timeshift, unit, scheduler)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit)"><code>window(timespan, unit)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit, rx.Scheduler)"><code>window(timespan, unit, scheduler)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit, int)"><code>window(timespan, unit, count)</code></a> and <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(long, java.util.concurrent.TimeUnit, int, rx.Scheduler)"><code>window(timespan, unit, count, scheduler)</code></a></li>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#window(rx.Observable, rx.functions.Func1)"><code>window(windowOpenings, closingSelector)</code></a></li>
<li>RxJS: <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewindowwindowopenings-windowboundaries-windowclosingselector"><code>window</code></a>, <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewindowwithcountcount-skip"><code>windowWithCount</code></a>, <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewindowwithtimetimespan-timeshift--scheduler"><code>windowWithTime</code></a>, and <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypewindowwithtimeorcounttimespan-count-scheduler"><code>windowWithTimeOrCount</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/system.reactive.linq.observable.window.aspx"><code>Window</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/17_SequencesOfCoincidence.html#Window">Introduction to Rx: Window</a></li>
</ul>

<hr>

<h2 id="cast( )">cast( )</h2>

<h4 id="cast-all-items-from-the-source-observable-into-a-particular-type-before-reemitting-them">cast all items from the source Observable into a particular type before reemitting them</h4>

<p><img src="/assets/operators/cast.png" width="640" height="305" />​</p>

<h4 id="see-also:">see also:</h4>

<ul>
<li>javadoc: <a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html#cast(java.lang.Class)"><code>cast(class)</code></a></li>
<li>Linq: <a href="http://msdn.microsoft.com/en-us/library/hh211842(v=vs.103).aspx"><code>Cast</code></a></li>
<li><a href="http://www.introtorx.com/Content/v1.0.10621.0/08_Transformation.html#CastAndOfType">Introduction to Rx: Cast and OfType</a></li>
</ul>

    </div>
    <div class="col-sm-4">
    <ul class="side-menu">
      <li><a href="/documentation.html">Getting Started</a></li>
      <li><a href="/documentation/observable.html">Observable</b></a></li>
      <li><a href="/documentation/operators.html">Operators</a></li>
      <li><a href="/documentation/subject.html">Subject</a></li>
      <li><a href="/documentation/scheduler.html">Scheduler</a></li>
      <li><a href="/documentation/plugins.html">Plugins</a></li>
      <li>
        <a href="#">Language Adapters</a>
        <ul>
            <li><a href="#">Groovy</a></li>
            <li><a href="#">Clojure</a></li>
            <li><a href="#">Scala</a></li>
            <li><a href="#">JRuby</a></li>
            <li><a href="#">Kotlin</a></li>
          </ul>
      </li>
      <li><a href="/contribute.html">How to Contribute</a></li>
      <li><a href="http://netflix.github.io/RxJava/javadoc/rx/Observable.html" target="_BLANK">Javadoc</a></li>
    </ul>
    </div>
  </div>
</div>

    </div>

    <footer>
      <div class="container">

        <div class="row">
          <div class="col-sm-3">
            <ul class="footer-section">
              <li><h4>Documentation</h4></li>
              <li><a href="/documentation.html">Getting Started</a></li>
<li><a href="/documentation/observable.html">Observable</a></li>
<li><a href="/documentation/operators.html">Operators</a></li>
<li><a href="/documentation/subject.html">Subject</a></li>
<li><a href="/documentation/scheduler.html">Scheduler</a></li>
<li><a href="/documentation/backpressure.html">Backpressure</a></li>
<li><a href="/documentation/errors.html">Error handling</a></li>

            </ul>
          </div>

          <div class="col-sm-3">
            <ul class="footer-section">
              <li><h4>Languages</h4></li>
              <li><a href="https://github.com/ReactiveX/RxJava">RxJava<span class="external-link"></span></a></li>
<li><a href="https://github.com/Reactive-Extensions/RxJS">RxJS<span class="external-link"></span></a></li>
<li><a href="https://github.com/Reactive-Extensions/Rx.NET">Rx.NET<span class="external-link"></span></a></li>
<li><a href="/rxscala">RxScala</a></li>
<li><a href="https://github.com/ReactiveX/RxClojure">RxClojure<span class="external-link"></span></a></li>
<li><a href="/languages.html">Others</a></li>

            </ul>
          </div>

          <div class="col-sm-3">
            <ul class="footer-section">
              <li><h4>Resources</h4></li>
              <li><a href="/tutorials.html">Tutorials</a></li>
<!-- Uncomment only when ready
<li><a href="/releases.html">Releases and Binaries</a></li>
<li><a href="#">Code samples</a></li>
<li><a href="#">Presentations</a></li>
<li><a href="#">Related Projects</a></li>
<li><a href="#">Who uses Rx</a></li>
 -->

            </ul>
          </div>

          <div class="col-sm-3">
            <ul class="footer-section">
              <li><h4>Community</h4></li>
              <li><a href="https://github.com/ReactiveX">GitHub<span class="external-link"></span></a></li>
<li><a href="https://twitter.com/ReactiveX">Twitter<span class="external-link"></span></a></li>
<li><a href="/community.html">Others</a></li>

            </ul>
          </div>
        </div>

        <div class="row">
          <div class="col-sm-12 disclaimer">
            <img class="footer-logo" src="/assets/Rx_Logo_BW_S.png" />
            <a href="">ReactiveX<span class="external-link"></span></a> is a collection of open source projects. The content of this
            page is licensed under Creative Commons Attribution 3.0 License, and
            code samples are licensed under the BSD License.
          </div>
        </div>
      </div>
    </footer>

    <!-- back to top link -->
    <span id="top-link-block" class="hidden">
        <a href="#top" class="well well-sm" onclick="$('html,body').animate({scrollTop:0},'slow');return false;">
            <i class="glyphicon glyphicon-chevron-up"></i>
        </a>
    </span>

    <!-- Activate current page menu button -->
    <script>$("#menu-transforming-observables").addClass("active");</script>

    <!-- Polymer Paper Tabs -->
    <link rel="import" href="/polymer/components/paper-tabs/paper-tabs.html">
    <!-- Polymer Code Snippet Element-->
    <link rel="import" href="/polymer/elements/code-snippet.html">
    <link rel="import" href="/polymer/elements/tabs-panel.html">
    <link rel="import" href="/polymer/elements/tab-code.html">

    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="/js/bootstrap.min.js"></script>
    <!-- Prism -->
    <script src="/js/prism.js"></script>
    <script src="/js/prism.clojure.js"></script>
    <!-- Google Closure -->
    <script src="/js/goog/base.js"></script>

    <script>
        goog.require('goog.html.SafeHtml');
    </script>

    <script>
        /* Dynamic "Back to top" link */
        if ( ($(window).height() + 100) < $(document).height() ) {
            $('#top-link-block').removeClass('hidden').affix({
                offset: {top:100}
            });
        }
    </script>

  </body>
</html>
